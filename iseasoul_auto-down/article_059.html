<h3>Original Link: <a href=http://iseasoul.diandian.com/wf2011-solution>http://iseasoul.diandian.com/wf2011-solution</a></h3>
<article>
 <h3 data-postname="Pattern Translations">
  <a href="#" onclick="return false" style="cursor:default;">
   ACM/ICPC WF 2011 Solution by iSea
  </a>
 </h3>
 <p class="date ">
  21th of February 2012
 </p>
 <p class="date " style="margin-top:-1.2em;">
  <a href="/?tag=Last%20Task" target="_blank">
   Last Task
  </a>
 </p>
 <!-- 内容页面 全文 -->
 <p>
 </p>
 <p>
  写这个就要不免的回忆起去年的WF，OpenLegend的沉重谢幕。
  <br/>
 </p>
 <p>
  这套题目，较往年，风格确实有所变化，那种算法很杂重在实现的题目基本没有，取代的是，更加标准的算法题目，很多的数学猜想与临场分析，没变的是，题目依旧充满trick，测试数据非常强大，程序实现必须谨慎而优美。
 </p>
 <p>
  数学性加强也并不代表题目很难想到算法，因此回过头来做这套题，大多数题目都是有着比较清晰的思路的，但去年一幕如何发生呢？再看来也算正常了，题目会做你就一定做得出？没有好的状态和平和的心态，不能淡定的打好草稿然后认真code，凭什么比赛就应该如你所愿？像A这种本来属于我们擅长的题目，却苦思不得其解，或许就是当时现状的最好写照了。
 </p>
 <p>
  遗憾总是在那，督促着我，加快脚步。
 </p>
 <p>
 </p>
 <p>
  闲话完毕。写解题报告。
 </p>
 <p>
 </p>
 <p>
  A题：定义一种指令，仅包括两种操作A与M，每执行一次A，将当前的数加上a，每执行一次M，将当前的数加上m。给你两个数a与m，两个区间[p, q] 和 [r, s]，设计一串指令，使得区间[p, q] 中的数执行指令后，都在区间[r, s] 中。要求指令最短且字典序最小。数字都在[1, 10^9] 范围内。
 </p>
 <p>
  首先观察，M操作的个数是不会很大的。枚举之。
 </p>
 <p>
  为了方便定义，我们认为A操作0次也是合法的，那么最终的指令串形式一定是p[0]A - M - p[1]A- M - … - p[n-1]A - M - p[n]A 这样的。那么枚举了M操作的次数后，问题就转化为了使操作合法的前提下sigma(p[i]) 最小。对于x属于 [p, q]，经此操作得到的数就是
 </p>
 <p>
  <span class="text-img-holder">
   <img height="63" src="http://m3.img.srcdd.com/farm3/d/2012/0326/16/404387A22D43B126408889FB668EF9FB_B500_900_438_63.JPEG" width="438"/>
  </span>
  <br/>
 </p>
 <p>
  简单的转化后，问题就变成求一个m进制下的数，在区间[r’,s’] 中，且m进制表示下，每一位数的和加起来最小。怎么做？再简单不过的贪心了。
 </p>
 <p>
  至于指令的长度，字典序啊，你会发现也很好处理。
 </p>
 <p>
 </p>
 <p>
  B题：给出两组二维点A和B，每组3个。定义三种变换，scale缩放比例为非零整数，translate平移变换都是整数，rotate旋转变换角度最多有80种（方法已给出）。变换顺序也给定为rotate C scale C translate。问A组点能否通过某种变换到B组，如果能，变换是否全部等价（即变换对其他点是否也只有一种结果）。
 </p>
 <p>
  这是这场比赛的一个纸老虎，命题人甚至认为这道题目是整个比赛最简单的题目之一，最后却成了夺牌甚至决胜题。由此可见，写一个不坑爹的题面是多么重要。当然，你要说英语阅读也是重要能力之一，那也行。
 </p>
 <p>
  题目的算法简单而直接，枚举，判断。但要把一些细节写的简单而巧妙，也需要一点功夫，但确定你真的弄清楚了这个“等价”，写上个把小时，还是绰绰有余的。
 </p>
 <p>
  注意rotate和scale两个操作都完全相反时，是正好可以抵掉的，也就是等价了。其他的时候，如果可以同时映射过来，就是不等价的。
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
  C题：给出6个字母的形状，从一个01矩阵中识别出这些字母。
 </p>
 <p>
  这类图像识别题算是比较常见的题了，简单到形状固定，麻烦到用特征向量，连通度等等来识别字母或数字。而本题的关键在于观察：这6个字母包含的“洞”的数目是不相同的。所谓的“洞”，就是指完全被字母包含而不与外界连通的块。这就变成了本题的任务。
 </p>
 <p>
  解决方案？DFS，BFS，随意了。
 </p>
 <p>
 </p>
 <p>
  E题：给出N个二维点，有Q次询问，每次询问给出一个距离D，找到一个点，使点集中与其曼哈顿距离不超过D的点数最多，多个点时输出序为：y最小，x最小。所有的坐标都在[1, 1000] 范围内。
 </p>
 <p>
  由于范围的制约，使得枚举成为可能。这时的问题是：给出一个点，求出与其曼哈顿距离不超过D的点数。曼哈顿距离通过绝对值的展开，可以得到一个很优美的性质，距离为
 </p>
 <p>
  <span class="text-img-holder">
   <img height="36" src="http://m2.img.srcdd.com/farm3/d/2012/0326/16/4E8A2B097E4154AF4262008C495898F0_B500_900_404_36.JPEG" width="404"/>
  </span>
  <br/>
 </p>
 <p>
 </p>
 <p>
  那么变换坐标(x, y) 为(x + y, x C y)，曼哈顿距离不超过D就变成了四个边长为D的小矩形，即一个边长为2*D的大矩形。统计这个矩形中点的个数，就是那个再经典不过的二维容斥统计方法了。
 </p>
 <p>
 </p>
 <p>
  F题：在D天内，一个公司需要不断通过买进卖出一些可以创造价值的机器来获得最大化的利益。他拥有的初始资金为C。机器台数为N(&lt;= 10^6)。每台机器只能在Di天买进，买进价格为Pi，买进后的第二天机器开始创造利益Gi，卖出价格为Ri。卖出和买进的当天机器都无法运行。但可以当天卖出另一台来买进新的。注意：公司最多只能拥有一台机器。
 </p>
 <p>
  我直到读了N遍题目才发现这个注意，如果没有记错，当时场上我们也没有读到这个条件。
 </p>
 <p>
  列出转移方程，这是一道非常标准的斜率优化的DP。按Di排序后，DP[i]表示第i台机器买入当天的最大利益，可得DP[i] = max(DP[j] + G[j] * (D[i] - D[j] - 1) + R[j]) - P[i]。点为(G[j], DP[j] - G[j] * (D[j] + 1) + R[j])，斜率为-D[i]。
 </p>
 <p>
  这是一个求最大值，斜率为负，点的X坐标无序，斜率有序的斜率优化类DP。
 </p>
 <p>
  在斜率优化中，两个都有序的问题最好解决，单调队列。
 </p>
 <p>
  点的X坐标有序，斜率有序次之，维护凸包，每次查找时二分斜率。
 </p>
 <p>
  点的X坐标无序，斜率有序是最麻烦的，需要维护一个可能往中间插入点的动态凸包。
 </p>
 <p>
  点的X坐标无序，斜率无序？两个都搞呗。（大部分这个问题都可以将一个排序转化一下。）
 </p>
 <p>
  于是这个题，就变成了标准的模板题，细节处理一下，其余无难度。
 </p>
 <p>
  来说模板，维护动态凸包，网上大多说用splay，表示不会如此“高级”的数据结构。哑熊教了我一种很好写也很方便的map维护方法，思路并不复杂。用一个map记录当前x坐标下最优的y（根据左右折而定），每次插入判断此时叉积，然后依次向左向右扫描，删除不合法的点。对于有序X坐标的查找，维护一个左指针即可。如果无序，就二分每两个点之间的斜率。
 </p>
 <p>
  说句实在话，我完全没有料到去年的final会有如此多的裸算法题，某方面也导致我们模板准备不足，知识储备更是不足。
 </p>
 <p>
 </p>
 <p>
  G题：一段被分为N段的木棒，第i段与第i+1段首尾相连，已知每段木棒的长度。现在利用这些木棒来围出一些封闭的多边形，可以首尾相连，但不能破坏已有的连接关系，使围出的多边形面积之和最大。木棒段数 &lt;= 500。
 </p>
 <p>
  需要澄清一下题意，例如有7段stick，一种可能的划分为(s7, s1, s2), s3 unused, (s4, s5, s6)，显然，划分完成后，木棒的顺序是没有关系的。如果对于一组划分中的木棒，我们可以计算出围出的最大多边形，这就是一个“矩阵链乘“的经典DP，复杂度O(n^3)。
 </p>
 <p>
  转过来考虑第一个问题，对于一组划分中的木棒，计算可以围出的最大多边形。这个问题，在现场，天王说过一个国家队论文中的结论，所有的点共圆（具体证明我也不知道 = =）。于是可以二分半径，验证圆周角的和。注意可能存在钝角三角形这样类似的情形。
 </p>
 <p>
  对于每个区间，计算最大面积的复杂度为 O(N * logR)，所有的区间就是O(N^3 * logR)，就是解决问题的复杂度。问题到这里，复杂度虽然有点高，得到了一个不错的解决方法。现场赛中，开始我们误认为木棒是无序的，直接求了总区间的最优值。样例没过后发现问题，但是由于还有其他题可做，而DP复杂度过高，最终被放弃。我看了现场赛中哑熊写的程序，除了二分上界的小bug，加上DP，是可以通过这道题的。
 </p>
 <p>
  但是问题确实可以做到更好，我们观察这个问题，如果围出的多边形中，不存在一个圆心角大于pi，构造出一个半径较大但是只位于半圆中的多边形，这个区间会因为分隔成更小的区间而获得更优解吗？不会，半径更小，每段stick对应的面积更小，和一定更小。从而猜想，对于一个区间，只有两种情况需要拆分：1) 最长的比其余加起来长，这时围不成多边形；2) 出现大于pi的圆心角。这个猜想并不难证明，难在想到这样做决策。两种情况导致的结果是一样的：放弃最长的stick。这样一个DP就变成了一个O(N)的拆分，加上每一段计算面积的复杂度，总体复杂度完美的达到了O(N^2 * logR)。
 </p>
 <p>
  我非常喜欢这道题目，它既利用了一个十分优美的圆的性质，又融合了经典的DP思路，更巧妙的是，这个经典的DP是可以依据分析问题的特殊性质进行优化的！这才是思维之美啊，到最后，问题都是那么简单。
 </p>
 <p>
 </p>
 <p>
  H题：一个无向无权图，现在需要选取一些点放置shaft，使得如果图中的某一个点被破坏时，其他所有点都可以通过其他点和边到达至少一个选取的点。求最少的放置数，以及不同的放置方法数。
 </p>
 <p>
  这道题目是比完赛被我诟病吐槽过很多次的，这么裸露的算法题。自己之后学了割点与双连通分量，也第一时间做掉了这道题。其实，这个题从猜想到实现都不难，是难得的图论中需要自己猜想进而证明实现的好题目。而那些不满，无非是为自己找的托词罢了。
 </p>
 <p>
  比赛中，我们的已经得到了正确的算法：求点双连通分量，对于度为1的分量，需要放置一个shaft，放置方法为 分量点数-1 ，即除却这个割点外，都可以选择为放置点。其他度数&gt;=2的分量，在破坏某一个点时，都可以通过另一个割点逃离。对于度数为0的分量，需要放置两个位于不同位置的shaft，以防放置点被破坏，放置方法数为C(N, 2)。
 </p>
 <p>
  那么问题只剩下一步：求双连通分量。由于没带标程，就有了天王那句著名的话：我一辈子只会写错一次双连通分量，就是在final上。
 </p>
 <p>
  没带标程实质上只是另一个借口，在final的舞台上，竟然都不会写求割点，这么巧妙而神奇的trajan算法，可以将有向无向图全都缩成树，不学习，不理解，不是开玩笑吗？
 </p>
 <p>
 </p>
 <p>
  I题：你在原点，有N (&lt;= 10^5) 个僵尸，给出他们的坐标。每个时刻，你先移动，8个方向，或者不动，然后僵尸移动，每个僵尸都往最接近你的方向移动，同样是八个方向。下个时刻开始，你先移动，8个方向... 问你能够逃离僵尸魔爪最长多少时间。
 </p>
 <p>
  读完题，敏锐的solver正常都会有一个疑问，僵尸往最接近你的方向移动，如果两个方向一样最接近，走哪个呢？这是一个好问题，想清楚了这个问题，就戳穿了这个问题的最大幌子。
 </p>
 <p>
  这种情况会存在吗，对于一个点的八个方向，存在一个点，使得某两个方向的距离都一样且最小？随便在草纸上画吧，这种情况是不会出现的。也就是说，无论你在哪个店，僵尸总有最优的选择最接近你，也就是讲，该来的，你怎么都跑不掉。如果你与僵尸的距离满足某个条件，那么到达某个时刻，无论你如何走，都将被僵尸抓住。
 </p>
 <p>
  所以不用费心构造逃跑方法了，找出这个条件，如果这个条件足够lucky，就解决这个问题了。时间是显然满足二分性的，二分时间。得到判定性问题：在时刻T，能否存在一个点，任何僵尸都到达不了？
 </p>
 <p>
  在时刻T，所有僵尸，包括你自己，能够到达的点都构成一个正方形。问题就是：N个正方形的并，能否完全覆盖另一个正方形。再进一步，把N个正方形都与目标正方形求交，得到的N个矩形的面积并是否等于目标正方形。模板飞来。
 </p>
 <p>
  一个微小的不同，这里只要考虑整点，所以直接判断面积并是错误的，有可能覆盖了所有整点但没有覆盖整个正方形。比如(0, 1) (0, -1)和(0, 1) (0, -2)的答案应当是一样的。用一个很小但是很巧的技巧可以消除这个问题，有兴趣的可以思考一下。
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
  J题：利用方块来建pyramid，每一层都为N*N的正方形。一种是High的，每层正方形边长递减1，一种是Low的，每层递减2。现在有N (&lt;=10^6) 个方块，所有的都必须使用用来建立最少的pyramid。不能有相同的pyramid。相同个数最少的方案输出最大的包含方块最多的方案，依次定义优先级。输出方案。
 </p>
 <p>
  由于平方增长的速度比较快，推测pyramid的种类并不多。用程序简单的跑一下，可以发现不同个数为320。DP的复杂度是够了，三千万，但是别激动，要输出方案。
 </p>
 <p>
  比赛中，我很早就开了这个题，甚至有FB的幻想。但是一次又一次的WA的现实浇灭了理想，最终的board上，可以发现很多队伍也被卡在这道题目上很久，一道看上去很直接很老套的背包DP，究竟问题出在哪呢？
 </p>
 <p>
  这场比赛我前期的主要精力都消磨在这道题了，而所有的代码实质上是一个错误的DP。这个错误却又一叶障目，让人迟迟走不出来。前面说过，DP的时间复杂度是三千万，直接做的话，空间复杂度也是三千万*数据类型，接近几G的内存要求。这在现场赛虽然是可以的，但是对于大部分时间还是刷OJ的ACMer，显然不够放心。于是试图寻找各种优化方法减小内存，就有了各种形态各异但都是错误方法的DP记录，回溯答案。
 </p>
 <p>
  举我自己的错误方法。DP[i]记录i个方块能建立pyramid的最少值，pre[i]记录能转移过来的最小状态，输出N的拆分方案时，每次回溯到pre[n]的状态，保证当前组成的pyramid最大，递归处理。这个空间复杂度确实低，但是问题也很显然，由于输出的方案是pyramid递减的，就会遇到当前状态的pre[i]大于前一个输出的。修补方案，记录当前状态是否可行，如果出现大于的情况，枚举个数，回溯到可行的状态去。听上去挺好了，还是无情的WA。最后哑熊告诉我，DP求的都是错的，我才恍然大悟。
 </p>
 <p>
  就不可以直接进行DP转移啊！必须记录当前使用到那一个pyramid，这样才能保证不同这个条件。也就是说，根本就绕不过去，最简单，也是最好的办法就是记录一个bool变量，记录当前方块数使用到某个pyramid是否可行，然后回溯。这道题暴露的问题就是，想问题千万不要想当然，先入为主很可怕，思路清晰严谨才是人间正途。
 </p>
 <p>
  值得一提的是，这样写HDOJ还是过不了，虽然我建议刘老师把这个题的内存限制改大了，但由于没算好，128M还是不够用。在这儿通过的唯一方法就是暴搜。加一个最优性剪枝就行，最大的答案也只是6个而已，并且很快就找到了。
 </p>
 <p>
 </p>
 <p>
  K题：给出一个简单多边形，点数不超过100。需要使多边形通过一个管道，求管道的最小宽度。
 </p>
 <p>
  这是非常经典的旋转卡壳问题了。求凸包，然后对于每条边，求出所有点的最大距离。即求出每条边的对踵点。取这个距离的最小值就是答案。
 </p>
 <p>
  范围100的话，还不随意？“晚来天欲雪，能饮一杯无？”
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
  至此，除D外的十道题目我都尽自己的理解写了尽量详细的解决思路与方案。回头看，这十道题目没有任何一点无法理解的难点，没有实现起来的无从下手，都是完完全全可以想可以写的。但是真的写完，给自己带来的收获也同样如我想象般巨大。没关系，去年的心结算是解开了，分析理由已经早无所谓，而新的旅程，马上降临。在这只有冬寒稍微缓步春意无从觅得的古都，写下一篇如此长的解题报告，不为种下什么一定要开花结实的希望，只为曾经努力过。
 </p>
 <p>
  至于剩下的D，待我细细研究后再单独写一篇上来。
 </p>
 <p>
  以飨。
 </p>
 <p>
  『请感谢伤害你的人，因为他磨炼了你的心志！请感谢绊倒你的人，因为他强化了你的双腿！请感谢欺骗你的人，因为他增进了你的智慧！请感谢藐视你的人，因为他觉醒了你的自尊！请感谢遗弃你的人，因为他教会了你该独立！』――not by 点点网
  <a href="http://www.diandian.com/?ref=crawler">
   点点网
  </a>
 </p>
 <p>
 </p>
 <div class="footnotes">
  <hr>
   <div id="notes" style="">
    <a name="jjlnotes">
    </a>
    <iframe allowtransparency="true" frameborder="0" height="0" id="diandian_comments" scrolling="no" src="http://www.diandian.com/n/common/comment?feedId=afc9dd20-78c8-11e1-beaa-782bcb383976&amp;notesTextColor=%23131313&amp;notesLinkColor=%23131313&amp;notesBlockQuoteColor=&amp;notesBlockBgColor=%23ffffff&amp;notesBlockBorderColor=&amp;notesBlockBgOpacity=0&amp;notesOperationLinkColor=&amp;notesEnableBorderRadius=&amp;notesIframeId=" width="530">
    </iframe>
   </div>
  </hr>
 </div>
</article>
