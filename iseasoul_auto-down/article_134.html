<h3>Original Link: <a href=http://iseasoul.diandian.com/post/2011-04-13/14763490>http://iseasoul.diandian.com/post/2011-04-13/14763490</a></h3>
<article>
 <h3 data-postname="Pattern Translations">
  <a href="#" onclick="return false" style="cursor:default;">
   All-Ukrainian School Olympiad in Informatics
  </a>
 </h3>
 <p class="date ">
  13th of April 2011
 </p>
 <p class="date " style="margin-top:-1.2em;">
  <a href="/?tag=Last%20Acm" target="_blank">
   Last Acm
  </a>
 </p>
 <!-- 内容页面 全文 -->
 <p>
 </p>
 <p>
  这套题目出的很好，至少好于大部分CF正式的比赛。
 </p>
 <p>
  A 最小生成树的一个性质，在所有生成树中，最大边最小
 </p>
 <p>
  所以按一个排序后维护当前最小生成树，规模不大，每次DFS即可
 </p>
 <p>
  B 贪心，每个mouse找到最近的cheese，尽量先前一个离它最近的，除非已经被占据
 </p>
 <p>
  C 很巧妙的集合DP，不是很懂rng_58大神的代码
 </p>
 <p>
  D 我是按位处理的，其实有很简单的公式，知道^是不带进位的加法就会推了
 </p>
 <p>
  E 简单推公式题
 </p>
 <p>
  F 不错的DP优化题目，被很多高中生秒杀，Orz
 </p>
 <p>
  O(n^2)的DP是很显然的，要优化，就要发掘一下条件：
 </p>
 <p>
 </p>
 <p>
  <span>
   ll getK1(const event&amp; e) {
  </span>
 </p>
 <p>
  <span>
   return (ll)v * e.t - e.x;
  </span>
 </p>
 <p>
  <span>
   }
  </span>
 </p>
 <p>
  <span>
   ll getK2(const event&amp; e) {
  </span>
 </p>
 <p>
  <span>
   return (ll)v * e.t + e.x;
  </span>
 </p>
 <p>
  <span>
   }
  </span>
 </p>
 <p>
  <span>
   // from X to Y &lt;=&gt;
  </span>
  <span>
   K1_X &gt;= K1_Y &amp;&amp; K2_X &gt;= K2_Y
  </span>
 </p>
 <p>
 </p>
 <p>
  我开始试图用维护LIS的方法来搞，发现把这个&amp;&amp;当成了||，所以悲剧了
 </p>
 <p>
  树状数组或线段树显然是可以维护的，但膜拜了rng_58的代码后，学到了一种map维护increaing序列的方法
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
  <span>
   <span>
    mpit it = mp.upper_bound(x);
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    if (it != mp.begin()) {
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    cur = (--it)-&gt;second + 1;
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    }
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    mp[x] = cur;
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    while (true) {
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    it = mp.upper_bound(x);
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    if (it == mp.end() || it-&gt;second &gt; cur) {
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    break;
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    }
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    mp.erase(it);
   </span>
  </span>
 </p>
 <p>
  <span>
   <span>
    }
   </span>
  </span>
 </p>
 <p>
 </p>
 <p>
 </p>
 <p>
  实质是和维护LIS的方法差不多的，注意想清楚细节。
 </p>
 <p>
 </p>
 <p>
  『如来者，无所从来，亦无所去，故名如来。』――not by 点点网
  <a href="http://www.diandian.com/?ref=crawler">
   点点网
  </a>
 </p>
 <p>
 </p>
 <div class="footnotes">
  <hr>
   <div id="notes" style="">
    <a name="jjlnotes">
    </a>
    <iframe allowtransparency="true" frameborder="0" height="0" id="diandian_comments" scrolling="no" src="http://www.diandian.com/n/common/comment?feedId=b47d7a20-78c8-11e1-beaa-782bcb383976&amp;notesTextColor=%23131313&amp;notesLinkColor=%23131313&amp;notesBlockQuoteColor=&amp;notesBlockBgColor=%23ffffff&amp;notesBlockBorderColor=&amp;notesBlockBgOpacity=0&amp;notesOperationLinkColor=&amp;notesEnableBorderRadius=&amp;notesIframeId=" width="530">
    </iframe>
   </div>
  </hr>
 </div>
</article>
