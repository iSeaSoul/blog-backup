<h3>Original Link: <a href=http://ryan-daily.diandian.com/facebook-hackercup-2014-sol>http://ryan-daily.diandian.com/facebook-hackercup-2014-sol</a></h3>
<article>
 <h3 data-postname="Pattern Translations">
  <a href="#" onclick="return false" style="cursor:default;">
   Facebook HackerCup 2014 Solution
  </a>
 </h3>
 <p class="date ">
  3th of March 2015
 </p>
 <p class="date " style="margin-top:-1.2em;">
  <a href="/?tag=tutorial" target="_blank">
   tutorial
  </a>
  <a href="/?tag=algorithm" target="_blank">
   algorithm
  </a>
  <a href="/?tag=hackercup" target="_blank">
   hackercup
  </a>
 </p>
 <!-- 内容页面 全文 -->
 <p>
 </p>
 <h3>
  <strong>
   Round 1
  </strong>
 </h3>
 <p>
  <strong>
   Labelmaker 10pts
  </strong>
 </p>
 <p>
  Get the length of the target string, then do a K-inary switching.
 </p>
 <p>
  <strong>
   Coins Game 20pts
  </strong>
 </p>
 <p>
  A tricky greedy problems: Distribute K coins in N boxes, then the order of boxes may be shuffled, for one guess, point a box and check the box, gain one coin if it contains at least one, what's the minimum guess time to find C coins?
 </p>
 <p>
  First, calculate the minimum X each box should contains so that
  <code>
   N * X &gt;= C
  </code>
  , which is, the minimum number so that each move will ensure a coin found. Then for X, calculate the maximum number M of non-empty boxes coins can fill. Keep the other boxes empty, which will waste us at most one time, at the other boxes will ensure at least X coins found.
 </p>
 <p>
  The final code is fairly simple:
 </p>
 <pre config="brush:python;toolbar:false;">
def solve():
    N, K, C = read_int()
    min_num = (C + N - 1) // N
    num_empty = max(0, N - K // min_num)

    return G + num_empty
</pre>
 <p>
  P.S. The maximum guess time should be G + N - 1.
 </p>
 <p>
  <strong>
   AAAAAA 25pts
  </strong>
 </p>
 <p>
  Given a maze, find the longest path from the upper-left corner to the lower-right corner. Only one upwards or leftwards is allowed.
 </p>
 <p>
  Calculate two DP values, enumerate the row line or column line to make a single connection. That's an
  <code>
   O(N^3)
  </code>
  solution.
 </p>
 <p>
  Use the state
  <code>
   max_step[pos_x, pos_y, dir, turn_used]
  </code>
  can we make a
  <code>
   O(N^2)
  </code>
  dp solution.
 </p>
 <p>
  <strong>
   Preventing Alzheimer's 40pts
  </strong>
 </p>
 <p>
  Given N numbers, add each of them a delta-value so that GCD of any two of them is K. Minimize the sum of the delta-values.
 </p>
 <p>
  As the value less than 50 and number N &lt;= 20. At most N prime factors are needed. So a bitmask DP is feasible. Increase the number less than K to K first, if has one or more zero, keep a single zero. Then for the left number, increase them be the multiple of K, use the divisor for the bitmask DP with state
  <code>
   min_delta_value_sum[idx, mask]
  </code>
  .
 </p>
 <h3>
  <strong>
   Code Link
  </strong>
 </h3>
 <p>
  <a href="https://github.com/iSeaSoul/gcj/tree/master/GNYP/hackercup/2014">
   https://github.com/iSeaSoul/gcj/tree/master/GNYP/hackercup/2014
  </a>
 </p>
 <p>
  点xuS点GGWwang
  <a href="http://www.diandian.com/?ref=crawler">
   点点网
  </a>
 </p>
 <p>
 </p>
 <div class="footnotes">
  <hr>
   <div id="notes" style="">
    <a name="jjlnotes">
    </a>
    <iframe allowtransparency="true" frameborder="0" height="0" id="diandian_comments" scrolling="no" src="http://www.diandian.com/n/common/comment?feedId=9aa80bf0-c1a0-11e4-830d-d4ae52a7bec4&amp;notesTextColor=%23131313&amp;notesLinkColor=%23131313&amp;notesBlockQuoteColor=&amp;notesBlockBgColor=%23ffffff&amp;notesBlockBorderColor=&amp;notesBlockBgOpacity=0&amp;notesOperationLinkColor=&amp;notesEnableBorderRadius=&amp;notesIframeId=" width="530">
    </iframe>
   </div>
  </hr>
 </div>
</article>
